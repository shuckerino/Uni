Problem: Producer-Consumer-Problem (Erzeuger-Verbraucher-Problem)
Producer: incoming calls from customer
Consumer: counselors in call center

// Semaphore definitions
shared int waiting_spots = 0  // Number of free spots in the waiting queue
shared int counselor_spots = 3  // Number of available counselor spots
shared semaphore mutex = 1  // Semaphore to protect shared memory
shared semaphore waiting_spots_sem = 1  // Semaphore for accessing the waiting queue
shared semaphore counselor_sem = 1  // Semaphore for accessing counselor spots
shared semaphore wait_time_sem = 1  // Semaphore to control the announcements


// Process for incoming calls
process Incoming_Call {
    while (true) {
        sleep(random_time(0, 2))  // Random arrival time between 0 and 2 minutes
        wait(mutex)
        if (waiting_spots < 4) {
            waiting_spots++
            signal(mutex)
            wait(waiting_spots_sem)
            wait(wait_time_sem)
            // Call is received
            signal(wait_time_sem)
            wait(mutex)
            waiting_spots--
            signal(mutex)
            signal(counselor_sem)
        } else {
            // Waiting queue is full, call is declined
            signal(mutex)
            send_message("The hotline is currently overloaded. Please try again later.")
        }
    }
}


// Process for Counselor
process Counselor {
    while (true) {
        wait(counselor_sem)
        wait(mutex)
        counselor_spots--
        signal(mutex)
        // Counselor receives call
        sleep(random_time(0, 5))  // Random duration of the counseling session between 0 and 5 minutes
        wait(mutex)
        counselor_spots++
        signal(mutex)
        signal(counselor_sem)
    }
}


// Simulation
main() {
    start process Incoming_Call
    start 3 processes Counselor
    wait for all processes to finish
}

